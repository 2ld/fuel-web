#!/usr/bin/env ruby

require 'naily'

require 'logger'
require 'ostruct'
require 'optparse'
require 'amqp'

options = OpenStruct.new
options.daemonize = false
options.pidfile = '/var/run/nailyd.pid'
options.config_path = '/etc/naily/nailyd.conf'
options.log_path = nil
options.log_level = 'debug'

OptionParser.new do |opts|
  opts.banner = 'Usage: nailyd [options]'

  opts.separator ''
  opts.separator 'Options:'

  opts.on('-d', '--[no-]daemonize', 'Daemonize server')    { |flag| options.daemonize = flag }
  opts.on('-P', '--pidfile PATH', 'Path to pidfile')       { |path| options.pidfile = path }
  opts.on('-c', '--config PATH', 'Use custom config file') do |path|
    unless File.exists?(path)
      puts "Error: config file #{options.config_path} was not found"
      exit
    end

    options.config_path = path
  end

  opts.on('-l', '--logfile PATH' 'Log file path') do |path|
    options.log_path = path
  end

  levels = %w{fatal error warn info debug}
  opts.on('--loglevel LEVEL', levels, "Logging level (#{levels.join(', ')})") do |level|
    options.log_level = level
  end

  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end

  opts.on_tail('-v', '--version', 'Show version') do
    puts Naily::VERSION
    exit
  end
end.parse!

config = Naily::Config.default
config.update(Naily::Config.load(options.config_path)) if File.exists?(options.config_path)

if options.daemonize
  # After daemonize we can't log to STDOUT, pick a default log file
  options.log_path ||= "#{Dir.pwd}/naily.log"

  require 'daemons'
  Daemons.daemonize :app_name => 'naily'

end

Naily.logger = options.log_path ? Logger.new(options.log_path) : Logger.new(STDOUT)
Naily.logger.level = Logger.const_get(options.log_level.upcase)

begin
  File.open(options.pidfile, 'w') { |f| f.write($$) } if options.daemonize
rescue
  Naily.logger.error "Exception: #{$!}"
end

def connection_options(config)
  {
    :host => config[:broker_host],
    :port => config[:broker_port],
    :username => config[:broker_username],
    :password => config[:broker_password],
  }.reject { |k, v| v.nil? }
end

Naily.logger.info "Starting..."

EM.run do
  AMQP.logging = true
  connection = AMQP.connect(connection_options(config))
  channel = AMQP::Channel.new(connection)
  channel.on_error do |ch, error|
    Naily.logger.fatal "Channel error #{error.inspect}"
    stop(connection)
  end
  exchange = channel.topic(config[:broker_exchange], :durable => true)

  producer = Naily::Producer.new(channel, exchange)
  delegate = config[:delegate] || Naily::Dispatcher.new(config, producer)

  server = Naily::Server.new(config, channel, exchange, delegate)
  server.run

  # Example
  #reporter = Naily::Reporter.new(producer, "some_method")
  #reporter.report("some haha")

  Signal.trap('INT')  do
    Naily.logger.info "Got INT signal, stopping"
    stop(connection)
  end

  Signal.trap('TERM') do
    Naily.logger.info "Got TERM signal, stopping"
    stop(connection)
  end

  def stop(connection, &block)
    if connection
      connection.close { EM.stop(&block) }
    else
      EM.stop(&block)
    end
  end
end

File.unlink(options.pidfile) if options.daemonize
